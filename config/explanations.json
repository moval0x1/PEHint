{
  "en": {
    "DOS Header": {
      "title": "DOS Header (MZ Header)",
      "description": "The DOS header is the first structure in every PE file. It was originally designed for DOS compatibility but now serves as a legacy header that points to the actual PE header. The magic number 'MZ' (0x5A4D) identifies this as a valid executable file.",
      "purpose": "Provides backward compatibility and contains the offset to the PE header",
      "security_notes": "Legacy header - no direct security implications, but must be present for valid PE files"
    },
    "PE Header": {
      "title": "PE Header (File Header)",
      "description": "The PE header contains essential information about the file format, including the target machine type, number of sections, and characteristics. It follows the DOS header and contains the core PE format information.",
      "purpose": "Define the basic PE file structure and characteristics",
      "security_notes": "Critical for file validation - check Machine field for unexpected architectures and Characteristics for suspicious flags"
    },
    "Optional Header": {
      "title": "Optional Header",
      "description": "The optional header contains detailed information about the executable, including entry point, image base, section alignment, and subsystem information. It's essential for the Windows loader to properly load and execute the file.",
      "purpose": "Provide detailed loading and execution information for the Windows loader",
      "security_notes": "Critical security fields include EntryPoint, ImageBase, and DllCharacteristics. Unusual values may indicate malicious modifications."
    },
    "Sections": {
      "title": "PE Sections",
      "description": "Sections contain the actual code, data, and resources of the executable. Each section has specific characteristics and permissions that determine how it's loaded into memory and what operations are allowed.",
      "purpose": "Organize executable content into logical, loadable segments with specific permissions",
      "security_notes": "Critical for security analysis - check section characteristics for suspicious permissions, look for hidden sections, and verify section alignment"
    },
    "Data Directories": {
      "title": "Data Directories",
      "description": "Data directories point to important structures within the file, such as import/export tables, resources, and security information. They provide the loader with locations of critical data needed for execution.",
      "purpose": "Locate important data structures for loading and execution",
      "security_notes": "Import/Export directories are critical for security analysis. Check for suspicious imports, unexpected exports, and verify directory integrity"
    },
    "e_magic": {
      "title": "Magic Number (e_magic)",
      "description": "This 16-bit value must be 0x5A4D ('MZ' in ASCII). It's the signature that identifies this file as a valid DOS executable. The 'MZ' stands for Mark Zbikowski, one of the original DOS developers.",
      "value": "Always 0x5A4D (0x5A = 'M', 0x4D = 'Z')",
      "purpose": "File format validation and identification",
      "security_notes": "Critical validation field - any other value indicates file corruption or manipulation. Malware authors sometimes try to modify this to bypass basic file type detection."
    },
    "e_cblp": {
      "title": "Bytes on Last Page (e_cblp)",
      "description": "The number of bytes on the last page of the file. This field is used to determine the exact size of the file.",
      "purpose": "Calculate exact file size for DOS compatibility",
      "security_notes": "Unusual values might indicate file manipulation or padding."
    },
    "e_cp": {
      "title": "Pages in File (e_cp)",
      "description": "The number of pages in the file. In DOS, files were organized in 512-byte pages.",
      "purpose": "DOS file size calculation",
      "security_notes": "Legacy field with minimal security implications."
    },
    "e_crlc": {
      "title": "Relocations (e_crlc)",
      "description": "The number of relocation entries in the file. These are used to adjust addresses when the file cannot be loaded at its preferred base address.",
      "purpose": "Handle address space conflicts in DOS",
      "security_notes": "High numbers might indicate complex relocations or manipulation."
    },
    "e_cparhdr": {
      "title": "Size of Header (e_cparhdr)",
      "description": "The size of the header in paragraphs (16-byte units). This includes the DOS header and any additional header information.",
      "purpose": "Define header boundaries",
      "security_notes": "Unusual header sizes might indicate header manipulation."
    },
    "e_minalloc": {
      "title": "Minimum Allocation (e_minalloc)",
      "description": "The minimum number of paragraphs of memory that the program needs to run.",
      "purpose": "Define minimum memory requirements",
      "security_notes": "Very high values might indicate memory allocation attacks."
    },
    "e_maxalloc": {
      "title": "Maximum Allocation (e_maxalloc)",
      "description": "The maximum number of paragraphs of memory that the program can use.",
      "purpose": "Define maximum memory requirements",
      "security_notes": "Unusually high values might indicate memory exhaustion attacks."
    },
    "e_ss": {
      "title": "Initial SS (e_ss)",
      "description": "The initial value of the SS register (stack segment) when the program starts.",
      "purpose": "Set up initial stack location",
      "security_notes": "Unusual stack locations might indicate stack manipulation."
    },
    "e_sp": {
      "title": "Initial SP (e_sp)",
      "description": "The initial value of the SP register (stack pointer) when the program starts.",
      "purpose": "Set up initial stack pointer",
      "security_notes": "Unusual stack pointers might indicate stack overflow attempts."
    },
    "e_csum": {
      "title": "Checksum (e_csum)",
      "description": "A checksum value for the file. This field is often set to 0 in modern PE files.",
      "purpose": "File integrity verification",
      "security_notes": "Non-zero checksums should be validated. Zero is normal for modern files."
    },
    "e_ip": {
      "title": "Initial IP (e_ip)",
      "description": "The initial value of the IP register (instruction pointer) when the program starts.",
      "purpose": "Set up initial execution point",
      "security_notes": "Unusual instruction pointers might indicate code injection."
    },
    "e_cs": {
      "title": "Initial CS (e_cs)",
      "description": "The initial value of the CS register (code segment) when the program starts.",
      "purpose": "Set up initial code segment",
      "security_notes": "Unusual code segments might indicate segment manipulation."
    },
    "e_lfarlc": {
      "title": "File Address of Relocation Table (e_lfarlc)",
      "description": "The file address of the relocation table. This points to the relocation entries.",
      "purpose": "Locate relocation information",
      "security_notes": "Unusual relocation table locations might indicate manipulation."
    },
    "e_ovno": {
      "title": "Overlay Number (e_ovno)",
      "description": "The overlay number. This field is typically 0 for the main program.",
      "purpose": "Identify overlay segments",
      "security_notes": "Non-zero values might indicate overlay-based malware."
    },
    "e_lfanew": {
      "title": "PE Header Offset (e_lfanew)",
      "description": "This 32-bit value contains the file offset to the PE header. It tells the loader where to find the actual Portable Executable header within the file. This offset is typically 0x80 (128 bytes) or larger.",
      "purpose": "Locate the PE header for modern Windows execution",
      "calculation": "File offset from beginning of file to PE signature",
      "security_notes": "Suspicious if offset is very large (>0x1000) - could indicate file padding to hide malicious content. Also check if offset points to valid PE signature."
    },
    "Signature": {
      "title": "PE Signature",
      "description": "The PE signature that identifies this as a valid Portable Executable file. Must be 0x00004550 ('PE\\0\\0' in ASCII).",
      "purpose": "Validate PE file format",
      "security_notes": "Critical validation field - any other value indicates file corruption or manipulation."
    },
    "Machine": {
      "title": "Machine Type",
      "description": "Specifies the target CPU architecture for this executable. Common values include: 0x014C (Intel 386), 0x8664 (AMD64), 0x01C0 (ARM), 0xAA64 (ARM64).",
      "purpose": "Ensure the executable runs on compatible hardware",
      "security_notes": "Check for architecture mismatch - running 64-bit malware on 32-bit system or vice versa. Some malware uses multiple architectures in single file."
    },
    "NumberOfSections": {
      "title": "Number of Sections",
      "description": "Indicates how many sections are defined in the section table. Each section represents a logical division of the executable (code, data, resources, etc.). Typical executables have 3-10 sections.",
      "purpose": "Define the file's logical structure and memory layout",
      "security_notes": "Suspicious if very few sections (<3) or too many (>15). Few sections might indicate packed/obfuscated code. Many sections could indicate code injection or complex malware."
    },
    "TimeDateStamp": {
      "title": "Time/Date Stamp",
      "description": "Contains the timestamp when the executable was created or last modified. This is stored as seconds since January 1, 1970 (Unix epoch).",
      "purpose": "Version tracking and build identification",
      "security_notes": "Check for suspicious timestamps: future dates, very old dates, or dates matching known malware campaigns. Timestamp manipulation is common in malware."
    },
    "PointerToSymbolTable": {
      "title": "Pointer to Symbol Table",
      "description": "Points to the COFF symbol table. This is typically 0 in modern PE files as symbol information is usually stored in separate PDB files.",
      "purpose": "Locate debugging symbol information",
      "security_notes": "Non-zero values in release builds might indicate debug information left behind or manipulation."
    },
    "NumberOfSymbols": {
      "title": "Number of Symbols",
      "description": "The number of symbols in the COFF symbol table. This is typically 0 in modern PE files.",
      "purpose": "Define symbol table size",
      "security_notes": "Non-zero values in release builds might indicate debug information left behind or manipulation."
    },
    "SizeOfOptionalHeader": {
      "title": "Size of Optional Header",
      "description": "The size of the optional header in bytes. This field indicates how much optional header data follows the PE header.",
      "purpose": "Define optional header boundaries",
      "security_notes": "Unusual sizes might indicate header manipulation or corruption."
    },
    "Characteristics": {
      "title": "File Characteristics",
      "description": "A set of flags that describe the executable's properties: 0x0002 (Executable), 0x2000 (DLL), 0x0001 (Relocation info stripped), 0x0100 (32-bit word machine).",
      "purpose": "Define file type and behavior",
      "security_notes": "DLL characteristics in EXE files are suspicious. Stripped relocation info can indicate packed malware. Check for unusual combinations of flags."
    },
    "Magic": {
      "title": "Magic Number",
      "description": "Identifies the type of optional header: 0x010B (PE32), 0x020B (PE32+).",
      "purpose": "Determine header format and size",
      "security_notes": "Must match file architecture. Mismatch could indicate file corruption or manipulation. Some malware tries to confuse analysis tools."
    },
    "MajorLinkerVersion": {
      "title": "Major Linker Version",
      "description": "The major version of the linker that created this executable.",
      "purpose": "Identify build tools and compatibility",
      "security_notes": "Very old or very new linker versions might indicate suspicious compilation or manipulation."
    },
    "MinorLinkerVersion": {
      "title": "Minor Linker Version",
      "description": "The minor version of the linker that created this executable.",
      "purpose": "Identify build tools and compatibility",
      "security_notes": "Very old or very new linker versions might indicate suspicious compilation or manipulation."
    },
    "SizeOfCode": {
      "title": "Size of Code",
      "description": "The size of the code section in bytes. This represents the total size of all code sections combined.",
      "purpose": "Define code section requirements",
      "security_notes": "Suspicious if very large or very small compared to file size. Could indicate code injection or obfuscation."
    },
    "SizeOfInitializedData": {
      "title": "Size of Initialized Data",
      "description": "The size of the initialized data section in bytes. This includes all data sections that contain initialized values.",
      "purpose": "Define initialized data requirements",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "SizeOfUninitializedData": {
      "title": "Size of Uninitialized Data",
      "description": "The size of the uninitialized data section (BSS) in bytes. This section is filled with zeros at load time.",
      "purpose": "Define uninitialized data requirements",
      "security_notes": "Large BSS sections might indicate malware trying to allocate memory for unpacking or code injection."
    },
    "AddressOfEntryPoint": {
      "title": "Address of Entry Point",
      "description": "The relative virtual address (RVA) where execution begins when the program starts. This points to the first instruction that will be executed.",
      "purpose": "Define the starting point of program execution",
      "format": "RVA relative to image base",
      "security_notes": "CRITICAL SECURITY FIELD! Suspicious if: 1) Points to data section (not code), 2) Very low address (<0x1000), 3) Points to last section, 4) Points to overlay. These often indicate packed malware or code injection."
    },
    "BaseOfCode": {
      "title": "Base of Code",
      "description": "The RVA of the beginning of the code section when loaded into memory.",
      "purpose": "Define code section base address",
      "security_notes": "Unusual base addresses might indicate code injection or manipulation."
    },
    "BaseOfData": {
      "title": "Base of Data",
      "description": "The RVA of the beginning of the data section when loaded into memory. This field is only present in PE32 files.",
      "purpose": "Define data section base address",
      "security_notes": "Unusual base addresses might indicate data injection or manipulation."
    },
    "ImageBase": {
      "title": "Image Base",
      "description": "The preferred base address in memory where the executable should be loaded. The default is 0x00400000 for 32-bit and 0x0000000140000000 for 64-bit executables.",
      "purpose": "Optimize memory layout and reduce relocation overhead",
      "security_notes": "Endereços base incomuns podem indicar malware tentando evitar detecção ou conflito com outros processos. Verifique valores não padrão."
    },
    "SectionAlignment": {
      "title": "Section Alignment",
      "description": "The alignment of sections in memory. Sections are aligned to this boundary when loaded into memory. Common values are 0x1000 (4KB) for 32-bit and 0x2000 (8KB) for 64-bit.",
      "purpose": "Optimize memory layout and performance",
      "security_notes": "Unusual alignment values might indicate manipulation or non-standard compilation."
    },
    "FileAlignment": {
      "title": "File Alignment",
      "description": "The alignment of sections in the file. Raw data is aligned to this boundary on disk. Common values are 0x200 (512 bytes) or 0x1000 (4KB).",
      "purpose": "Optimize file I/O performance",
      "security_notes": "Unusual file alignment might indicate manipulation or non-standard compilation."
    },
    "MajorOperatingSystemVersion": {
      "title": "Major Operating System Version",
      "description": "The major version number of the operating system required to run this executable.",
      "purpose": "Define OS compatibility requirements",
      "security_notes": "Unusual OS version requirements might indicate targeted malware or compatibility issues."
    },
    "MinorOperatingSystemVersion": {
      "title": "Minor Operating System Version",
      "description": "The minor version number of the operating system required to run this executable.",
      "purpose": "Define OS compatibility requirements",
      "security_notes": "Unusual OS version requirements might indicate targeted malware or compatibility issues."
    },
    "MajorImageVersion": {
      "title": "Major Image Version",
      "description": "The major version number of the image itself. This is typically set by the developer.",
      "purpose": "Version tracking and identification",
      "security_notes": "Unusual version numbers might indicate manipulation or fake versioning."
    },
    "MinorImageVersion": {
      "title": "Minor Image Version",
      "description": "The minor version number of the image itself. This is typically set by the developer.",
      "purpose": "Version tracking and identification",
      "security_notes": "Unusual version numbers might indicate manipulation or fake versioning."
    },
    "MajorSubsystemVersion": {
      "title": "Major Subsystem Version",
      "description": "The major version number of the subsystem required to run this executable.",
      "purpose": "Define subsystem compatibility requirements",
      "security_notes": "Unusual subsystem version requirements might indicate compatibility issues or manipulation."
    },
    "MinorSubsystemVersion": {
      "title": "Minor Subsystem Version",
      "description": "The minor version number of the subsystem required to run this executable.",
      "purpose": "Define subsystem compatibility requirements",
      "security_notes": "Unusual subsystem version requirements might indicate compatibility issues or manipulation."
    },
    "Win32VersionValue": {
      "title": "Win32 Version Value",
      "description": "Reserved field that should be 0. This field is not used by the Windows loader.",
      "purpose": "Reserved for future use",
      "security_notes": "Non-zero values might indicate file corruption or non-standard PE format."
    },
    "SizeOfImage": {
      "title": "Size of Image",
      "description": "The total size of the image when loaded into memory, including all headers and sections.",
      "purpose": "Define memory allocation requirements",
      "security_notes": "Unusual image sizes might indicate code injection or manipulation."
    },
    "SizeOfHeaders": {
      "title": "Size of Headers",
      "description": "The combined size of the DOS stub, PE header, and section headers.",
      "purpose": "Define header size requirements",
      "security_notes": "Unusual header sizes might indicate header manipulation or corruption."
    },
    "CheckSum": {
      "title": "CheckSum",
      "description": "A checksum value for the image. This field is used for integrity verification.",
      "purpose": "Image integrity verification",
      "security_notes": "Non-zero checksums should be validated. Zero is normal for many files."
    },
    "Subsystem": {
      "title": "Subsystem",
      "description": "Specifies the Windows subsystem that will run this executable: 2 (Windows GUI), 3 (Windows CUI), 1 (Native), 5 (OS/2 CUI).",
      "purpose": "Determine how Windows should handle the application",
      "security_notes": "Native subsystem (1) in user-mode executables is suspicious - indicates kernel-mode code running in user space. Could be rootkit or privilege escalation attempt."
    },
    "DllCharacteristics": {
      "title": "DLL Characteristics",
      "description": "Flags that describe DLL-specific properties: 0x0001 (High entropy VA), 0x0002 (Dynamic base), 0x0004 (Force integrity), 0x0008 (NX compatible), 0x0010 (Isolation aware), 0x0020 (No SEH), 0x0040 (Do not bind), 0x0080 (App container), 0x0100 (WDM driver), 0x2000 (Terminal server aware).",
      "purpose": "Define DLL behavior and security features",
      "security_notes": "Missing security flags (NX compatible, Force integrity) might indicate vulnerable code. High entropy VA and Dynamic base help prevent ASLR bypasses."
    },
    "SizeOfStackReserve": {
      "title": "Size of Stack Reserve",
      "description": "The size of the stack to reserve in virtual memory. This is the maximum stack size the process can use.",
      "purpose": "Define stack memory allocation",
      "security_notes": "Very large stack reserves might indicate stack overflow attacks or memory exhaustion attempts."
    },
    "SizeOfStackCommit": {
      "title": "Size of Stack Commit",
      "description": "The size of the stack to commit in virtual memory. This is the initial stack size that is actually allocated.",
      "purpose": "Define initial stack allocation",
      "security_notes": "Unusual stack commit sizes might indicate manipulation or optimization attempts."
    },
    "SizeOfHeapReserve": {
      "title": "Size of Heap Reserve",
      "description": "The size of the local heap to reserve in virtual memory. This is the maximum heap size the process can use.",
      "purpose": "Define heap memory allocation",
      "security_notes": "Very large heap reserves might indicate memory exhaustion attacks or manipulation."
    },
    "SizeOfHeapCommit": {
      "title": "Size of Heap Commit",
      "description": "The size of the local heap to commit in virtual memory. This is the initial heap size that is actually allocated.",
      "purpose": "Define initial heap allocation",
      "security_notes": "Unusual heap commit sizes might indicate manipulation or optimization attempts."
    },
    "LoaderFlags": {
      "title": "Loader Flags",
      "description": "Flags that control the loader behavior: 0x0001 (Break on load), 0x0002 (Debug on load), 0x0004 (Default break on load), 0x0008 (Default debug on load), 0x0010 (Incremental link), 0x0020 (Suppress incremental link), 0x0040 (Safe SEH handler), 0x0080 (Guard CF), 0x0100 (Terminal server aware).",
      "purpose": "Control debugging and security features",
      "security_notes": "Debug flags enabled in release builds are suspicious. Missing security flags might indicate vulnerable code."
    },
    "NumberOfRvaAndSizes": {
      "title": "Number of RVA and Sizes",
      "description": "The number of data directory entries that follow. This should always be 16 for standard PE files.",
      "purpose": "Define the number of data directories",
      "security_notes": "Values other than 16 might indicate file corruption or non-standard PE format."
    },
    "Name": {
      "title": "Section Name",
      "description": "An 8-character name that identifies the section. Common names include .text (code), .data (data), .rdata (read-only data), .idata (imports), .edata (exports), .rsrc (resources), .reloc (relocations).",
      "purpose": "Identify section purpose and content",
      "common_names": ".text, .data, .rdata, .idata, .edata, .rsrc, .reloc, .pdata, .xdata",
      "security_notes": "Suspicious section names: UPX0/UPX1 (packed), .aspack, .vmp0 (VMProtect), .themida. Unusual names might indicate obfuscation or malware."
    },
    "SectionName": {
      "title": "Section Name",
      "description": "An 8-character name that identifies the section. Common names include .text (code), .data (data), .rdata (read-only data), .idata (imports), .edata (exports), .rsrc (resources), .reloc (relocations).",
      "purpose": "Identify section purpose and content",
      "common_names": ".text, .data, .rdata, .idata, .edata, .rsrc, .reloc, .pdata, .xdata",
      "security_notes": "Suspicious section names: UPX0/UPX1 (packed), .aspack, .vmp0 (VMProtect), .themida. Unusual names might indicate obfuscation or malware."
    },
    "Export Directory": {
      "title": "Export Directory",
      "description": "Contains information about functions and data that the module exports for use by other modules. This directory points to the export address table (EAT) which lists all exported symbols.",
      "purpose": "Enable other modules to import functions and data from this executable",
      "security_notes": "Critical for analysis - check for suspicious exported functions, unexpected exports, or missing exports that might indicate obfuscation"
    },
    "Import Directory": {
      "title": "Import Directory",
      "description": "Lists all modules and functions that this executable imports from other modules. Each import entry specifies the module name and the functions being imported.",
      "purpose": "Resolve dependencies on external functions and libraries at runtime",
      "security_notes": "Critical for security analysis - check for suspicious imports, unexpected DLLs, or imports from non-standard locations"
    },
    "Resource Directory": {
      "title": "Resource Directory",
      "description": "Contains application resources such as icons, bitmaps, strings, and version information. Resources are organized in a hierarchical structure.",
      "purpose": "Store application resources and assets for runtime use",
      "security_notes": "Check for hidden resources, suspicious embedded content, or resources that might contain malicious code"
    },
    "Exception Directory": {
      "title": "Exception Directory",
      "description": "Contains exception handling information for the executable. This directory is used by the Windows Structured Exception Handling (SEH) mechanism.",
      "purpose": "Handle runtime exceptions and errors gracefully",
      "security_notes": "Check for exception handlers that might be used for anti-debugging or code injection techniques"
    },
    "Certificate Directory": {
      "title": "Certificate Directory",
      "description": "Contains digital signature information and certificates for code signing. This verifies the authenticity and integrity of the executable.",
      "purpose": "Verify the identity of the software publisher and ensure code hasn't been tampered with",
      "security_notes": "Critical for security - unsigned executables or invalid certificates may indicate malicious software"
    },
    "Base Relocation Directory": {
      "title": "Base Relocation Directory",
      "description": "Contains relocation information for when the executable needs to be loaded at a different base address than its preferred base.",
      "purpose": "Enable the loader to relocate the executable to different memory addresses if needed",
      "security_notes": "Check for excessive relocations that might indicate ASLR bypass attempts or suspicious loading behavior"
    },
    "Debug Directory": {
      "title": "Debug Directory",
      "description": "Contains debug information such as line numbers, symbol tables, and other debugging data. This information is used by debuggers and development tools.",
      "purpose": "Provide debugging information for development and troubleshooting",
      "security_notes": "Debug information can reveal internal structure - its presence or absence might indicate obfuscation or stripping"
    },
    "Architecture Directory": {
      "title": "Architecture Directory",
      "description": "Contains architecture-specific data and information. This directory is used for specialized architectures or extended features.",
      "purpose": "Provide architecture-specific functionality and data",
      "security_notes": "Check for unexpected architecture data that might indicate cross-compilation or suspicious modifications"
    },
    "Global Pointer Directory": {
      "title": "Global Pointer Directory",
      "description": "Contains information about global pointers used by the executable. This is primarily used in RISC architectures.",
      "purpose": "Manage global pointer references for efficient memory access",
      "security_notes": "Unusual global pointer usage might indicate suspicious memory access patterns"
    },
    "TLS Directory": {
      "title": "TLS Directory",
      "description": "Contains Thread Local Storage information. TLS allows each thread to have its own copy of certain variables.",
      "purpose": "Provide thread-specific storage for multi-threaded applications",
      "security_notes": "Check for TLS callbacks that might be used for anti-debugging or initialization of malicious code"
    },
    "Load Configuration Directory": {
      "title": "Load Configuration Directory",
      "description": "Contains configuration information for how the executable should be loaded, including security features like Control Flow Guard and SEHOP.",
      "purpose": "Configure security features and loading behavior",
      "security_notes": "Critical for security analysis - check for disabled security features that might indicate malicious intent"
    },
    "Bound Import Directory": {
      "title": "Bound Import Directory",
      "description": "Contains pre-bound import information that can speed up loading by avoiding runtime import resolution.",
      "purpose": "Optimize loading performance by pre-binding imports",
      "security_notes": "Check for bound imports that might be used to hide suspicious import behavior"
    },
    "Import Address Table Directory": {
      "title": "Import Address Table Directory",
      "description": "Contains the Import Address Table (IAT) which stores the actual addresses of imported functions after they are resolved at runtime.",
      "purpose": "Store resolved addresses of imported functions for efficient calling",
      "security_notes": "Check for IAT hooking or suspicious import resolution that might indicate code injection"
    },
    "Delay Import Directory": {
      "title": "Delay Import Directory",
      "description": "Contains information about functions that are imported but not resolved until they are first called. This can improve startup performance.",
      "purpose": "Defer import resolution until functions are actually needed",
      "security_notes": "Check for delayed imports that might be used to hide suspicious behavior until runtime"
    },
    "COM+ Runtime Header Directory": {
      "title": "COM+ Runtime Header Directory",
      "description": "Contains COM+ runtime information and metadata. This directory is used by COM+ applications and services.",
      "purpose": "Provide COM+ runtime support and metadata for COM+ applications",
      "security_notes": "Check for COM+ runtime data that might be used for COM hijacking or suspicious COM object creation"
    },
    "Reserved": {
      "title": "Reserved Directory",
      "description": "Reserved for future use by Microsoft. This directory entry is not currently used but may be defined in future Windows versions.",
      "purpose": "Reserved for future Windows features and extensions",
      "security_notes": "Check for any data in reserved directories as this might indicate experimental or suspicious features"
    },
    "VirtualSize": {
      "title": "Virtual Size",
      "description": "The size of the section when loaded into memory. This may be different from the raw data size due to alignment requirements and padding.",
      "purpose": "Define memory allocation requirements",
      "note": "May include uninitialized data (BSS)",
      "security_notes": "Suspicious if virtual size >> raw size - could indicate unpacking or code injection. Very large virtual sizes might be malware trying to allocate excessive memory."
    },
    "VirtualAddress": {
      "title": "Virtual Address",
      "description": "The relative virtual address (RVA) where this section will be loaded in memory. This is relative to the image base address.",
      "purpose": "Define memory layout and section positioning",
      "format": "RVA relative to image base",
      "security_notes": "Suspicious if virtual address is very low (<0x1000) or overlaps with other sections. Could indicate code injection or section manipulation."
    },
    "SizeOfRawData": {
      "title": "Size of Raw Data",
      "description": "The actual size of the section data stored in the file. This represents the number of bytes that will be read from disk.",
      "purpose": "Define file I/O requirements",
      "note": "Must be aligned to file alignment boundary",
      "security_notes": "Suspicious if raw size is 0 but virtual size > 0 - indicates uninitialized data section that could be used for code injection. Very large raw sizes might indicate embedded malicious content."
    },
    "PointerToRawData": {
      "title": "Pointer to Raw Data",
      "description": "The file offset where the section's raw data begins. This tells the loader where to read the section data from disk.",
      "purpose": "Locate section data within the file",
      "format": "File offset from beginning of file",
      "security_notes": "Check for suspicious offsets pointing to overlay or very large values. Could indicate hidden malicious content or file manipulation."
    },
    "PointerToRelocations": {
      "title": "Pointer to Relocations",
      "description": "Pointer to the relocation table for this section. This is typically 0 in modern PE files.",
      "purpose": "Locate section relocation information",
      "security_notes": "Non-zero values might indicate complex relocations or manipulation."
    },
    "PointerToLinenumbers": {
      "title": "Pointer to Line Numbers",
      "description": "Pointer to the line number table for this section. This is typically 0 in release builds.",
      "purpose": "Locate debugging line number information",
      "security_notes": "Non-zero values in release builds might indicate debug information left behind or manipulation."
    },
    "NumberOfRelocations": {
      "title": "Number of Relocations",
      "description": "The number of relocation entries for this section. Relocations are needed when the section cannot be loaded at its preferred virtual address.",
      "purpose": "Handle address space conflicts",
      "note": "Usually 0 for most sections in modern executables",
      "security_notes": "High number of relocations in unusual sections might indicate code injection or manipulation. Check if relocations point to suspicious addresses."
    },
    "NumberOfLinenumbers": {
      "title": "Number of Line Numbers",
      "description": "The number of line number entries for this section. These are used for debugging to map machine code back to source code.",
      "purpose": "Support debugging and development",
      "note": "Usually 0 in release builds",
      "security_notes": "Line numbers in suspicious sections might help trace malware origin. Missing line numbers in code sections could indicate obfuscation."
    },
    "SectionCharacteristics": {
      "title": "Section Characteristics",
      "description": "Flags that define the section's properties and permissions. Common flags: 0x20 (contains code), 0x40 (contains initialized data), 0x80 (contains uninitialized data), 0x20000000 (executable), 0x80000000 (readable), 0x40000000 (writable).",
      "purpose": "Define section permissions and behavior",
      "common_flags": "0x20 (code), 0x40 (data), 0x80 (BSS), 0x20000000 (executable), 0x80000000 (readable), 0x40000000 (writable)",
      "security_notes": "CRITICAL: Executable data sections (0x40 + 0x20000000) are highly suspicious - indicates code injection. Writable code sections (0x20 + 0x40000000) suggest self-modifying code or malware."
    },
    "Section": {
      "title": "PE Section",
      "description": "A section in a Portable Executable file represents a logical division of the executable's content. Each section contains specific types of data (code, initialized data, resources, etc.) and has defined characteristics that determine how it's loaded into memory and what operations are allowed.",
      "purpose": "Organize executable content into logical, loadable segments with specific permissions and attributes",
      "note": "Common section names include .text (executable code), .data (initialized data), .rdata (read-only data), .rsrc (resources), .reloc (relocations), .idata (imports), and .edata (exports)",
      "security_notes": "Critical for security analysis - check section characteristics for suspicious permissions (especially W+X combinations), look for hidden or obfuscated sections, verify section alignment, and examine unusual section names that might indicate packing or obfuscation."
    },
    "VirtualAddress_DataDir": {
      "title": "Data Directory RVA",
      "description": "The relative virtual address (RVA) of the data directory entry.",
      "purpose": "Locate data directory content in memory",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Size_DataDir": {
      "title": "Data Directory Size",
      "description": "The size of the data directory entry in bytes.",
      "purpose": "Define data directory content size",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "OriginalFirstThunk": {
      "title": "Original First Thunk",
      "description": "RVA to the original thunk table containing function names and ordinals.",
      "purpose": "Locate import function information",
      "security_notes": "Manipulation of this field can hide imported functions or redirect imports."
    },
    "TimeDateStamp_Import": {
      "title": "Import Time/Date Stamp",
      "description": "Timestamp when the import was bound. 0 indicates not bound, -1 indicates bound.",
      "purpose": "Track import binding status",
      "security_notes": "Unusual timestamps might indicate import manipulation or binding issues."
    },
    "ForwarderChain": {
      "title": "Forwarder Chain",
      "description": "Index into the forwarder chain. -1 if no forwarders.",
      "purpose": "Handle forwarded exports",
      "security_notes": "Complex forwarder chains might indicate obfuscation or redirection."
    },
    "Name_Import": {
      "title": "Import DLL Name",
      "description": "RVA to the name of the DLL being imported from.",
      "purpose": "Identify imported DLL",
      "security_notes": "Check for suspicious DLL names or imports from non-standard locations."
    },
    "FirstThunk": {
      "title": "First Thunk",
      "description": "RVA to the import address table (IAT) that will be filled with function addresses.",
      "purpose": "Locate import address table",
      "security_notes": "IAT manipulation is common in malware to hide imported functions."
    },
    "Characteristics_Export": {
      "title": "Export Characteristics",
      "description": "Reserved field that should be 0.",
      "purpose": "Reserved for future use",
      "security_notes": "Non-zero values might indicate corruption or manipulation."
    },
    "TimeDateStamp_Export": {
      "title": "Export Time/Date Stamp",
      "description": "Timestamp when the export table was created.",
      "purpose": "Track export table creation time",
      "security_notes": "Unusual timestamps might indicate manipulation or fake exports."
    },
    "MajorVersion_Export": {
      "title": "Export Major Version",
      "description": "Major version number of the export table.",
      "purpose": "Version tracking",
      "security_notes": "Unusual version numbers might indicate manipulation."
    },
    "MinorVersion_Export": {
      "title": "Export Minor Version",
      "description": "Minor version number of the export table.",
      "purpose": "Version tracking",
      "security_notes": "Unusual version numbers might indicate manipulation."
    },
    "Name_Export": {
      "title": "Export Module Name",
      "description": "RVA to the name of the module that contains the exports.",
      "purpose": "Identify exporting module",
      "security_notes": "Verify module name matches expected values."
    },
    "OrdinalBase": {
      "title": "Ordinal Base",
      "description": "Starting ordinal number for exports.",
      "purpose": "Define export ordinal numbering",
      "security_notes": "Unusual ordinal bases might indicate manipulation."
    },
    "NumberOfFunctions": {
      "title": "Number of Functions",
      "description": "Total number of exported functions.",
      "purpose": "Define export table size",
      "security_notes": "Unusually large numbers might indicate code injection or fake exports."
    },
    "NumberOfNames": {
      "title": "Number of Names",
      "description": "Number of exported functions with names.",
      "purpose": "Define named export count",
      "security_notes": "Should match or be less than NumberOfFunctions."
    },
    "AddressOfFunctions": {
      "title": "Address of Functions",
      "description": "RVA to the array of function addresses.",
      "purpose": "Locate export function addresses",
      "security_notes": "Verify addresses point to valid code sections."
    },
    "AddressOfNames": {
      "title": "Address of Names",
      "description": "RVA to the array of function name pointers.",
      "purpose": "Locate export function names",
      "security_notes": "Verify names are valid and not suspicious."
    },
    "AddressOfNameOrdinals": {
      "title": "Address of Name Ordinals",
      "description": "RVA to the array of ordinal numbers.",
      "purpose": "Locate export ordinal mapping",
      "security_notes": "Verify ordinals are within valid range."
    },
    "NT Headers": {
      "title": "NT Headers",
      "description": "The NT Headers (also known as PE Headers) contain the core information about the Portable Executable file format. This section includes the PE signature, File Header, Optional Header, and Section Headers.",
      "purpose": "Provide the essential PE file structure information for the Windows loader",
      "note": "NT Headers structure: PE Signature (4 bytes) + File Header (20 bytes) + Optional Header (variable size) + Section Headers (40 bytes each)",
      "security_notes": "The NT Headers are critical for understanding the executable's structure. Malware often modifies these headers to hide malicious behavior or evade detection. Pay special attention to the EntryPoint, ImageBase, and DllCharacteristics fields in the Optional Header."
    },
    "Export Directory RVA": {
      "title": "Export Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Export Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Export Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Export Directory Size": {
      "title": "Export Directory Size",
      "description": "The Size field specifies the size in bytes of the Export Directory structure.",
      "purpose": "This field indicates how many bytes the Export Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Import Directory RVA": {
      "title": "Import Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Import Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Import Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Import Directory Size": {
      "title": "Import Directory Size",
      "description": "The Size field specifies the size in bytes of the Import Directory structure.",
      "purpose": "This field indicates how many bytes the Import Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Resource Directory RVA": {
      "title": "Resource Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Resource Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Resource Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Resource Directory Size": {
      "title": "Resource Directory Size",
      "description": "The Size field specifies the size in bytes of the Resource Directory structure.",
      "purpose": "This field indicates how many bytes the Resource Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Exception Directory RVA": {
      "title": "Exception Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Exception Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Exception Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Exception Directory Size": {
      "title": "Exception Directory Size",
      "description": "The Size field specifies the size in bytes of the Exception Directory structure.",
      "purpose": "This field indicates how many bytes the Exception Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Certificate Directory RVA": {
      "title": "Certificate Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Certificate Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Certificate Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Certificate Directory Size": {
      "title": "Certificate Directory Size",
      "description": "The Size field specifies the size in bytes of the Certificate Directory structure.",
      "purpose": "This field indicates how many bytes the Certificate Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Base Relocation Directory RVA": {
      "title": "Base Relocation Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Base Relocation Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Base Relocation Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Base Relocation Directory Size": {
      "title": "Base Relocation Directory Size",
      "description": "The Size field specifies the size in bytes of the Base Relocation Directory structure.",
      "purpose": "This field indicates how many bytes the Base Relocation Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Debug Directory RVA": {
      "title": "Debug Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Debug Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Debug Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Debug Directory Size": {
      "title": "Debug Directory Size",
      "description": "The Size field specifies the size in bytes of the Debug Directory structure.",
      "purpose": "This field indicates how many bytes the Debug Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Architecture Directory RVA": {
      "title": "Architecture Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Architecture Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Architecture Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Architecture Directory Size": {
      "title": "Architecture Directory Size",
      "description": "The Size field specifies the size in bytes of the Architecture Directory structure.",
      "purpose": "This field indicates how many bytes the Architecture Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Global Pointer Directory RVA": {
      "title": "Global Pointer Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Global Pointer Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Global Pointer Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Global Pointer Directory Size": {
      "title": "Global Pointer Directory Size",
      "description": "The Size field specifies the size in bytes of the Global Pointer Directory structure.",
      "purpose": "This field indicates how many bytes the Global Pointer Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "TLS Directory RVA": {
      "title": "TLS Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the TLS Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the TLS Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "TLS Directory Size": {
      "title": "TLS Directory Size",
      "description": "The Size field specifies the size in bytes of the TLS Directory structure.",
      "purpose": "This field indicates how many bytes the TLS Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Load Configuration Directory RVA": {
      "title": "Load Configuration Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Load Configuration Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Load Configuration Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Load Configuration Directory Size": {
      "title": "Load Configuration Directory Size",
      "description": "The Size field specifies the size in bytes of the Load Configuration Directory structure.",
      "purpose": "This field indicates how many bytes the Load Configuration Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Bound Import Directory RVA": {
      "title": "Bound Import Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Bound Import Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Bound Import Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Bound Import Directory Size": {
      "title": "Bound Import Directory Size",
      "description": "The Size field specifies the size in bytes of the Bound Import Directory structure.",
      "purpose": "This field indicates how many bytes the Bound Import Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Import Address Table Directory RVA": {
      "title": "Import Address Table Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Import Address Table Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Import Address Table Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Import Address Table Directory Size": {
      "title": "Import Address Table Directory Size",
      "description": "The Size field specifies the size in bytes of the Import Address Table Directory structure.",
      "purpose": "This field indicates how many bytes the Import Address Table Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Delay Import Directory RVA": {
      "title": "Delay Import Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Delay Import Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Delay Import Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Delay Import Directory Size": {
      "title": "Delay Import Directory Size",
      "description": "The Size field specifies the size in bytes of the Delay Import Directory structure.",
      "purpose": "This field indicates how many bytes the Delay Import Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "COM+ Runtime Header Directory RVA": {
      "title": "COM+ Runtime Header Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the COM+ Runtime Header Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the COM+ Runtime Header Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "COM+ Runtime Header Directory Size": {
      "title": "COM+ Runtime Header Directory Size",
      "description": "The Size field specifies the size in bytes of the COM+ Runtime Header Directory structure.",
      "purpose": "This field indicates how many bytes the COM+ Runtime Header Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    },
    "Reserved Directory RVA": {
      "title": "Reserved Directory RVA",
      "description": "The Relative Virtual Address (RVA) field specifies the virtual address where the Reserved Directory data structure begins in memory. RVA is an offset relative to the image base address.",
      "purpose": "This field points to the location of the Reserved Directory structure within the loaded image. If the value is 0, the directory is not present in this PE file.",
      "note": "RVA values are relative to the ImageBase. To convert to a file offset, you need to find which section contains this RVA and calculate: FileOffset = RVA - Section.VirtualAddress + Section.PointerToRawData",
      "security_notes": "Verify that RVA points to valid section content, not to overlay or invalid memory regions."
    },
    "Reserved Directory Size": {
      "title": "Reserved Directory Size",
      "description": "The Size field specifies the size in bytes of the Reserved Directory structure.",
      "purpose": "This field indicates how many bytes the Reserved Directory occupies. Combined with the RVA field, it defines the complete memory range where the directory data is located.",
      "note": "If both RVA and Size are 0, the directory is not used in this PE file. The size is typically fixed for each directory type, but can vary for some directories like Resources.",
      "security_notes": "Unusual sizes might indicate data injection or manipulation."
    }
  },
  "security_highlights": {
    "critical_fields": [
      "AddressOfEntryPoint",
      "SectionCharacteristics", 
      "Name_Import",
      "e_lfanew"
    ],
    "suspicious_patterns": [
      "RWX sections (Writable + Executable)",
      "Entry point in data section",
      "Zero raw size with non-zero virtual size",
      "Unusual number of sections",
      "Suspicious import combinations",
      "Future or very old timestamps",
      "Non-standard image base addresses"
    ],
    "malware_techniques": [
      "Code injection via section manipulation",
      "Packing/obfuscation via section characteristics",
      "Anti-analysis via suspicious imports",
      "Overlay attacks via PE header manipulation",
      "Multi-architecture malware",
      "Timestamp manipulation",
      "Section name obfuscation"
    ]
  }
}
